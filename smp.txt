import re

def extract_sections(text):
    # Define regex patterns for "Drivers:" and "Checks:"
    drivers_pattern = r"Drivers:\s*((?:[^\n]+\n?)*)"
    checks_pattern = r"Checks:\s*((?:[^\n]+\n?)*)"

    # Extract drivers section
    drivers_match = re.search(drivers_pattern, text, re.DOTALL)
    drivers_section = drivers_match.group(1).strip() if drivers_match else ""

    # Extract checks section
    checks_match = re.search(checks_pattern, text, re.DOTALL)
    checks_section = checks_match.group(1).strip() if checks_match else ""

    # Convert sections into dictionaries for easier use
    drivers = parse_section(drivers_section)
    checks = parse_section(checks_section)

    return drivers, checks

def parse_section(section):
    """
    Parse a section of the text to a dictionary.
    """
    lines = section.splitlines()
    result = {}
    for line in lines:
        if line.strip():
            key, value = line.split(':', 1)
            result[key.strip()] = value.strip()
    return result

# Example string
text = """
Check order's quantity does not exceed the configured value of Quantity check type.
For orders with lower quantity than Quantity, expect to pass

For orders with greater quantity than Quantity, expect to be rejected due to GIM breach.
Also for LotQuantity.

Limit Rule 229261

Drivers:
  Destination[755, eq]: TW-Cash
  IssueType[issueType, eq]: Equity
  AppTagValue[323, eq]: TART
  orderType[40, eq]: Market

Checks:
  MaxQuantity: 0 [limitCheckId: 780756]
"""

# Extract and print the drivers and checks
drivers, checks = extract_sections(text)
print("Drivers:", drivers)
print("Checks:", checks)
